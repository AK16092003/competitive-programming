<snippet>
	<content><![CDATA[
				
struct node
{
	lli add;
	lli maxi;
};
 
 
struct segtree
{
	int size;
	vector<struct node> operations;
 
	struct node defval = {0ll ,0ll};
		
	void init(int n)
	{
		size = 1;
		while(size < n) size*=2;
		operations.assign(2*size , defval);
	}

 	struct node merge(struct node p1 , struct node p2)
 	{
 		struct node merge_node = defval;
 		// operation heress
 		merge_node.maxi = max(p1.maxi , p2.maxi);
 		return merge_node;
 	}
 
 
	struct node apply_operation(struct node x , struct node y)
	{
		struct node res = x;
		// y is parent , res is child
		res.add += y.add;
		return res;
	}
 
	void propagation(int x , int lx , int rx)
	{
		if(rx - lx == 1) 
		{
			// relax all lazy operations

			operations[x].maxi += operations[x].add;
			operations[x].add = 0;
			return;
		}
		else
		{
			operations[2*x+1] = apply_operation(operations[2*x+1] , operations[x]);
			operations[2*x+2] = apply_operation(operations[2*x+2] , operations[x]);
			
			// relax all lazy operations

			operations[x].maxi += operations[x].add;
			operations[x].add = 0;

		}
	}
 
	void set(int i , lli v, int x , int lx , int rx)
	{
		propagation(x , lx , rx);
		if(rx - lx == 1)
		{
			operations[x].maxi = v;
			return;
		}
		int m = (lx + rx)/2;
 
		if(i < m)
		{
			set(i, v ,2*x+1 , lx , m);
		}
		else{
			set(i, v ,2*x+2 , m , rx);
		}
 	}
 
	void set(int i , lli v)
	{
		set( i , v , 0 , 0 , size);
	}
 
	void range_update(int l , int r ,lli v, int x , int lx , int rx)
	{
		propagation(x , lx , rx);
		if(lx >= r || l >= rx) return ;
 
		if(l <= lx && r >= rx)
		{
			operations[x].add += v;
			propagation(x , lx , rx);
			return;
		}
 
		int m = (lx + rx)/2;
		range_update(l , r , v , 2*x+1 , lx , m);
		range_update(l , r , v , 2*x+2 , m , rx);
 
		propagation(2*x+1 , lx , m);
		propagation(2*x+2 , m , rx);

		operations[x] = merge(operations[2*x+1] , operations[2*x+2]);
 
	}
	void range_update(int l , int r , lli v)
	{
		range_update(l , r  , v, 0 , 0 , size);
	}
 
	struct node range_calc(int l , int r , int x , int lx , int rx)
	{
		propagation(x , lx , rx);
		if(lx >= r || l >= rx) return {0 , (lli)-inf};
 
		if(l <= lx && r >= rx)
		{
			return operations[x];
		}
 
		int m = (lx + rx)/2;
		// calculate

		propagation(2*x+1 , lx , m);
		propagation(2*x+2 , m , rx);

		operations[x] = merge(operations[2*x+1] , operations[2*x+2]);

		return merge(range_calc(l , r , 2*x+1 , lx , m) , range_calc(l , r , 2*x+2 , m , rx));
	}
 
	lli range_calc(int l , int r)
	{
		return range_calc(l , r , 0 , 0 , size).maxi;
	}
 
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>segtreelazy</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
